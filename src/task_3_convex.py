"""
出题者：柳文章，安徽大学人工智能学院
出题日期：2025.11.8

任务：编写函数 `convex_hull(points: list) -> list`

- 对输入的二维点集求解其凸包。
- 要求：给定点集 [(x,y), ...]，返回按逆时针顺序的凸包顶点列表（首尾不重复）。
- 知识点：排序、函数拆分、不可变返回、边界。
- 数学概念：二维点集的凸包，是指由这些点的所有凸组合组成的新的集合（大家参考这个链接了解一下：https://baike.baidu.com/item/%E5%87%B8%E5%8C%85/179150）。
"""


def convex_hull(points: list) -> list:
    """
    对输入的二维点集求解其凸包。

    提示：
        可以考虑用更直观的“礼物包装法 / Jarvis March”计算二维点集的凸包。如果能想到用其他更快的方法实现，则更好。

    算法思路：
      1) 选最“靠左”的点作为起点（x 最小，若并列取 y 最小）。
      2) 以当前点为“锚点”，枚举所有点，选择最“逆时针”的那个作为下一个点；
         若出现共线，则选择距离更远的点，以只保留边界两端点。
      3) 重复第 2 步，直到回到起点，栈中的点即为凸包（逆时针顺序）。
      4) 当输入不是可迭代的二维坐标点列表时，输出字符串“输入不符合要求，请输入可迭代的二维坐标点列表”

    Args:
        points (list): 二维点列表，例如 [(x1, y1), (x2, y2), ...]。x、y 为float型数据。

    Returns:
        list: 凸包顶点列表，按逆时针顺序排列，首尾不重复。
            若有效点数 < 3，则返回去重后的点集拷贝。

    Examples:
        >>> convex_hull([(0, 0), (1, 1), (1, 0), (0, 1)])
        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)]

        >>> convex_hull([(0, 0), (2, 0), (1, 0)])  # 共线仅保留两端
        [(0.0, 0.0), (2.0, 0.0)]
    """
    # TODO: 在下方完成程序


if __name__ == '__main__':
    points = [(0, 0), (1, 1), (1, 0), (0, 1), (0, 1.001)]
    support_points = convex_hull(points)
    print(support_points)
